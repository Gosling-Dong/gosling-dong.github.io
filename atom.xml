<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://gosling-dong.github.io</id>
    <title>大方志行</title>
    <updated>2019-07-17T02:37:56.551Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://gosling-dong.github.io"/>
    <link rel="self" href="https://gosling-dong.github.io/atom.xml"/>
    <subtitle>见天地，知轻重</subtitle>
    <logo>https://gosling-dong.github.io/images/avatar.png</logo>
    <icon>https://gosling-dong.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 大方志行</rights>
    <entry>
        <title type="html"><![CDATA[HWPanModal的使用]]></title>
        <id>https://gosling-dong.github.io/post/hwpanmodal-user</id>
        <link href="https://gosling-dong.github.io/post/hwpanmodal-user">
        </link>
        <updated>2019-07-17T01:34:21.000Z</updated>
        <content type="html"><![CDATA[<h3 id="hwpanmodal-用于从底部弹出控制器并用拖拽手势来关闭控制器支持任何">HWPanModal 用于从底部弹出控制器，并用拖拽手势来关闭控制器支持任何</h3>
<pre><code>1. 支持任何类型的UIViewController
2. 平滑的转场动画
3. 支持两种GestureRecognizer
* UIPanGestureRecognizer，上下拖拽视图。
* UIScreenEdgePanGestureRecognizer，侧滑关闭视图。
4. 支持编写自己的动画来呈现VC
5. 支持配置动画持续时间，AnimationOptions，springDamping
6. 支持配置背景alpha或模糊背景。 注意：动态更改模糊效果仅适用于iOS9.0 +
7. 显示/隐藏角落，指示灯。
8. 自动处理UIKeyboard显示/隐藏。
</code></pre>
<p>iOS 8.0+, support Objective-C &amp; Swift.</p>
<h3 id="依赖">依赖</h3>
<p><strong><a href="https://github.com/facebook/KVOController">KVOController</a></strong></p>
<h3 id="使用">使用</h3>
<pre><code>#import &lt;HWPanModal/HWPanModal.h&gt;    // 引入头文件

	///在需要的地方
[self presentPanModal:[AUIViewController new] sourceView:nil sourceRect:CGRectZero];

</code></pre>
<pre><code>	AUIViewController.m  中
  引入代理 &lt;HWPanModalPresentable&gt;
	
	//默认设置 可定制
- (PanModalHeight)shortFormHeight {
    return PanModalHeightMake(PanModalHeightTypeContent, 200);
}

	//PanModalHeightTypeContent   // from bottom

</code></pre>
<h3 id="全部代理方法">全部代理方法</h3>
<pre><code>
/**
 * HWPanModalPresentable为present配置协议
 * 默认情况下无需实现，只需Controller conforms 该协议
 * 通过category来默认实现以下所有方法。这样就不用通过继承来实现protocol
 */
@protocol HWPanModalPresentable &lt;NSObject&gt;

#pragma mark - ScrollView Config

/**
 * 支持同步拖拽的scrollView
 * 如果ViewController中包含scrollView并且你想scrollView滑动和拖拽手势同事存在，请返回此scrollView
 */
- (nullable UIScrollView *)panScrollable;

/**
 * 是否允许pan scroll view
 * 默认为YES
 */
- (BOOL)isPanScrollEnabled;

/**
 * scrollView指示器insets
 * Use `panModalSetNeedsLayoutUpdate()` when updating insets.
 */
- (UIEdgeInsets)scrollIndicatorInsets;

/**
 * 是否允许拖动额外拖动，如果panScrollable存在，且scrollView contentSize &gt; (size + bottomLayoutOffset),返回YES
 * 其余情况返回NO
 */
- (BOOL)allowsExtendedPanScrolling;

#pragma mark - Offset/position

/**
 * offset：屏幕顶部距离
 * 默认为topLayoutGuide.length + 21.0.
 */
- (CGFloat)topOffset;

/**
 * 当pan状态为short时候的高度
 * 默认状态下，shortFormHeight = longFormHeight
 */
- (PanModalHeight)shortFormHeight;

/**
 * 当pan状态为long的高度
 */
- (PanModalHeight)longFormHeight;

#pragma mark - Animation config

/**
 * spring弹性动画数值，默认未0.9
 */
- (CGFloat)springDamping;

/**
 * 转场动画时间，默认为0.5s
 */
- (NSTimeInterval)transitionDuration;

/**
 * 转场动画options
 * 默认为 UIViewAnimationOptionCurveEaseInOut | UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionBeginFromCurrentState
 */
- (UIViewAnimationOptions)transitionAnimationOptions;

#pragma mark - Background config

/**
 * 背景透明度，默认为0.7
 */
- (CGFloat)backgroundAlpha;

/**
 * Blur background
 * This function can NOT coexist with backgroundAlpha
 * Default use backgroundAlpha, Once you set backgroundBlurRadius &gt; 0, blur will work.
 * I recommend set the value 10 ~ 20.
 * @return blur radius
 */
- (CGFloat)backgroundBlurRadius;

/**
 * blur background color
 * @return color, default is White Color.
 */
- (nonnull UIColor *)backgroundBlurColor;

#pragma mark - User operation

/**
 * 该bool值控制当pan View状态为long的情况下，是否可以继续拖拽到PanModalHeight = MAX的情况
 * 默认为YES,即当已经拖拽到long的情况下不能再继续拖动
 */
- (BOOL)anchorModalToLongForm;

/**
 * 是否允许点击背景处dismiss presented Controller
 * 默认为YES
 */
- (BOOL)allowsTapBackgroundToDismiss;


/**
 * 是否允许drag操作dismiss presented Controller
 * 默认为YES
 */
- (BOOL)allowsDragToDismiss;

/**
 * 是否允许用户操作
 * 默认为YES
 */
- (BOOL)isUserInteractionEnabled;

/**
 * 是否允许屏幕边缘侧滑手势
 * 默认为NO，不允许
 */
- (BOOL)allowScreenEdgeInteractive;

/**
 * 是否允许触觉反馈
 * 默认为YES
 */
- (BOOL)isHapticFeedbackEnabled;

#pragma mark - Custom presentingViewController animation

/**
 * 是否对presentingViewController做动画效果，默认该效果类似淘宝/京东购物车凹陷效果
 * 默认为NO
 */
- (BOOL)shouldAnimatePresentingVC;

/**
 * 自定义presenting ViewController转场动画
 * 注意要使自定义效果生效，shouldAnimatePresentingVC 必须返回YES
 * 默认转场效果为凹陷动画效果，如果该方法返回不为空，则使用自定义动画效果
 * 默认为nil
 */
- (id&lt;HWPresentingViewControllerAnimatedTransitioning&gt;)customPresentingVCAnimation;

#pragma mark - Content UI config

/**
 * 是否顶部圆角
 * 默认为YES
 */
- (BOOL)shouldRoundTopCorners;

/**
 * 顶部圆角数值
 * 默认为8.0
 */
- (CGFloat)cornerRadius;

/**
 * 是否显示drag指示view
 * 默认为YES，该属性默认取‘- (BOOL)shouldRoundTopCorners’
 */
- (BOOL)showDragIndicator;

#pragma mark - Keyboard handle

/**
 * When there is text input view exists and becomeFirstResponder, will auto handle keyboard height.
 * Default is YES. You can disable it, handle it by yourself.
 */
- (BOOL)isAutoHandleKeyboardEnabled;


/**
 The offset that keyboard show from input view's bottom. It works when
 `isAutoHandleKeyboardEnabled` return YES.

 @return offset, default is 5.
 */
- (CGFloat)keyboardOffsetFromInputView;

#pragma mark - delegate

/**
 * 询问delegate是否需要使拖拽手势生效
 * 若返回NO，则禁用拖拽在presented view上
 * 默认为YES
 */
- (BOOL)shouldRespondToPanModalGestureRecognizer:(UIPanGestureRecognizer *)panGestureRecognizer;

/**
 * 当pan recognizer状态为begin/changed时，通知delegate回调。
 * 当拖动presented View时，该方法会持续的回调
 * 默认实现为空
 */
- (void)willRespondToPanModalGestureRecognizer:(UIPanGestureRecognizer *)panGestureRecognizer;

/**
 * 是否优先dismiss拖拽手势，当存在scrollView的情况下，如果此方法返回YES，则
 * dismiss手势生效，scrollView本身的滑动则不再生效。也就是说可以拖动Controller view，
 * 而scrollView没法拖动了
 *
 * 默认为NO
 */
- (BOOL)shouldPrioritizePanModalGestureRecognizer:(UIPanGestureRecognizer *)panGestureRecognizer;

/**
 * 是否应该变更panModal状态
 */
- (BOOL)shouldTransitionToState:(PresentationState)state;

/**
 * 通知回调即将变更状态
 */
- (void)willTransitionToState:(PresentationState)state;

/**
 * When you pan present controller to dismiss, and the view's y &lt;= shortFormYPos,
 * this delegate method will be called.
 * @param percent 0 ~ 1, 1 means has dismissed
 */
- (void)panModalGestureRecognizer:(UIPanGestureRecognizer *)panGestureRecognizer dismissPercent:(CGFloat)percent;

/**
 * 通知回调即将dismiss
 */
- (void)panModalWillDismiss;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 实体模型归档]]></title>
        <id>https://gosling-dong.github.io/post/ios-shi-ti-mo-xing-gui-dang</id>
        <link href="https://gosling-dong.github.io/post/ios-shi-ti-mo-xing-gui-dang">
        </link>
        <updated>2019-05-30T08:56:18.000Z</updated>
        <content type="html"><![CDATA[<h5 id="1归档是指用某种格式来保存一个或多个对象以便以后还原这些对象的过程-归档是将数据持久化的一种方式所谓数据持久化就是指在ios开发过程中将数据保存到本地能够让程序的运行更加流畅">1.归档是指用某种格式来保存一个或多个对象，以便以后还原这些对象的过程。归档是将数据持久化的一种方式（所谓数据持久化，就是指在IOS开发过程中，将数据保存到本地，能够让程序的运行更加流畅）。</h5>
<h1 id=""></h1>
<h5 id="2想要归档的数据对象需要遵守nscoding协议并且该对象对应的类必须提供encodewithcoder和initwithcoder方法">2.想要归档的数据对象，需要遵守NSCoding协议，并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法。</h5>
<h1 id="-2"></h1>
<h5 id="3归档就是将临时数据保存成本地文件">3.归档就是将临时数据保存成本地文件。</h5>
<h1 id="-3"></h1>
<h5 id="4归档的缺点归档的形式来保存数据只能一次性归档保存以及一次性解压-所以只能针对小量数据而且对数据操作比较笨拙即如果想改动数据的某一小部分还是需要解压整个数据或者归档整个数据">4.归档的缺点：归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，而且对数据操作比较笨拙，即如果想改动数据的某一小部分，还是需要解压整个数据或者归档整个数据。</h5>
<h1 id="-4"></h1>
<h2 id="小型数据建议用于用户信息">小型数据：建议用于用户信息</h2>
<p><strong>UserModel.h 文件</strong></p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface UserModel : NSObject&lt;NSCoding&gt;

@property (nonatomic , copy) NSString       *loginname;
@property (nonatomic , copy) NSString       *password;

@end



@interface ArchiveModel : NSObject

//  归档
+ (void)archiveTheModel(UserModel *)per;
//  解档
+ (UserModel *)loadArchiveTheModel ;
//  移除
+ (BOOL)removeDocumentWithFilePath;

@end
</code></pre>
<p><strong>UserModel.m 文件</strong></p>
<pre><code>#import &quot;UserModel.h&quot;
#import &lt;objc/runtime.h&gt;


@implementation UserModel

/**
 *  归档
 *
 *
 */
- (void)encodeWithCoder:(NSCoder *)aCoder
{
    unsigned int count;
    
    // 获得指向当前类的所有属性的指针
    objc_property_t *properties = class_copyPropertyList([self class], &amp;count);
    
    for (int i = 0; i &lt; count; i++) {
        // 获取指向当前类的一个属性的指针
        objc_property_t property = properties[i];
        // 获取C字符串属性名
        const char *name = property_getName(property);
        // C字符串转OC字符串
        NSString *propertyName = [NSString stringWithUTF8String:name];
        // 通过关键词取值
        NSString *propertyValue = [self valueForKeyPath:propertyName];
        // 编码属性
        [aCoder encodeObject:propertyValue forKey:propertyName];
    }
    free(properties);
}

- (id)initWithCoder:(NSCoder *)aDecoder
{
    if(self = [super init])
    {
        unsigned int count;
        // 获得指向当前类的所有属性的指针
        objc_property_t *properties = class_copyPropertyList([self class], &amp;count);
        for (int i = 0; i &lt; count; i++) {
            // 获取指向当前类的一个属性的指针
            objc_property_t property = properties[i];
            // 获取C字符串的属性名
            const char *name = property_getName(property);
            // C字符串转OC字符串
            NSString *propertyName = [NSString stringWithUTF8String:name];
            // 解码属性值
            NSString *propertyValue = [aDecoder decodeObjectForKey:propertyName];
            [self setValue:propertyValue forKey:propertyName];
        }
        // 记得释放
        free(properties);
    }
    return self;
}



@end





@implementation ArchiveModel

+ (void)archiveTheModel(UserModel *)per{
    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *filePath = [documentPath stringByAppendingPathComponent:@&quot;userInfo&quot;];
    [NSKeyedArchiver archiveRootObject:per toFile:filePath];
    NSLog(@&quot;归档:%@&quot;, filePath);
}


+ (UserModel *)loadArchiveTheModel {
    // 解档
    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *filePath = [documentPath stringByAppendingPathComponent:@&quot;userInfo&quot;];
    IsLoginUser *model = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];
    return model;
}



+ (BOOL)removeDocumentWithFilePath{
    NSString *documentPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *filePath = [documentPath stringByAppendingPathComponent:@&quot;userInfo&quot;];
    BOOL isRemove = true;
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if([[NSFileManager defaultManager]fileExistsAtPath:filePath]) {
        isRemove = [fileManager removeItemAtPath:filePath error:nil];
    }
    return isRemove;
}


@end


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 权限说明]]></title>
        <id>https://gosling-dong.github.io/post/ios-quan-xian-shuo-ming</id>
        <link href="https://gosling-dong.github.io/post/ios-quan-xian-shuo-ming">
        </link>
        <updated>2019-05-27T08:59:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<pre><code>Privacy - Media Library Usage Description               //获取用户媒体库说明
Privacy - Bluetooth Peripheral Usage Description        //蓝牙外设使用描述
Privacy - Calendars Usage Description                   //日历的使用说明
Privacy - Camera Usage Description                      //相机使用叙述说明
Privacy - Contacts Usage Description                    //联系人使用说明
Privacy - Health Share Usage Description                //健康分享使用描述
Privacy - Location Always Usage Description             //后台定位(在iOS设置中为'永久')
Privacy - Location Usage Description                    //需要定位
Privacy - Location When In Use Usage Description        //前台定位(在iOS设置中为'使用期间')
Privacy - Health Update Usage Description               //健康更新使用描述
Privacy - HomeKit Usage Description                  //HomeKit使用描述
Privacy - Microphone Usage Description                //麦克风的使用说明
Privacy - Motion Usage Description                    //运动使用的描述
Privacy - Photo Library Usage Description              //照片库使用说明
Privacy - Reminders Usage Description                 //提醒使用描述
Privacy - TV Provider Usage Description                 //电视提供商使用的描述 (貌似国内用不到)

iOS11新增
Privacy - NFC Reader Usage Description         //NFC使用描述
Privacy - Face ID Usage Descriptio                   //使用Face ID 
Privacy - Photo Library Additions Usage Description     //  保存图片到图库中 （重要）
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MacOS  监听窗口的改变]]></title>
        <id>https://gosling-dong.github.io/post/macos-jian-ting-chuang-kou-de-gai-bian</id>
        <link href="https://gosling-dong.github.io/post/macos-jian-ting-chuang-kou-de-gai-bian">
        </link>
        <updated>2017-10-20T08:24:15.000Z</updated>
        <content type="html"><![CDATA[<p>监听窗口拉伸，进入全屏，即将推出全屏，已经推出全屏，最小化，窗口关闭</p>
<h2 id="观察窗口拉伸">观察窗口拉伸</h2>
<pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(screenResize)name:NSWindowDidResizeNotificationobject:nil];

-(void)screenResize{

//NSLog(@&quot;观察窗口拉伸&quot;);

//NSLog(@&quot;%.2f===%.2f&quot;,self.view.bounds.size.width,self.view.bounds.size.height);

}
</code></pre>
<h2 id="即将进入全屏">即将进入全屏</h2>
<pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(willEnterFull:)name:NSWindowWillEnterFullScreenNotificationobject:nil];

-(void)willEnterFull:(NSNotification*)notification{

NSLog(@&quot;即将全屏&quot;);

}
</code></pre>
<h2 id="即将推出全屏">即将推出全屏</h2>
<pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(willExitFull:)name:NSWindowWillExitFullScreenNotificationobject:nil];

-(void)willExitFull:(NSNotification*)notification {

NSLog(@&quot;即将推出全屏&quot;);

}
</code></pre>
<h2 id="已经推出全屏">已经推出全屏</h2>
<pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(didExitFull:)name:NSWindowDidExitFullScreenNotificationobject:nil];

-(void)didExitFull:(NSNotification*)notification{

NSLog(@&quot;推出全屏&quot;);

}
</code></pre>
<h2 id="窗口最小化">窗口最小化</h2>
<pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(didMiniaturize:)name:NSWindowDidMiniaturizeNotificationobject:nil];

-(void)didMiniaturize:(NSNotification*)notification{

NSLog(@&quot;窗口变小&quot;);

}
</code></pre>
<h2 id="窗口即将关闭">窗口即将关闭</h2>
<pre><code>[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(willClose:)name:NSWindowWillCloseNotificationobject:nil];

-(void)willClose:(NSNotification*)notification{

NSLog(@&quot;窗口关闭&quot;);

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MacOS  NSButton 字体颜色]]></title>
        <id>https://gosling-dong.github.io/post/macos-nsbutton-zi-ti-yan-se</id>
        <link href="https://gosling-dong.github.io/post/macos-nsbutton-zi-ti-yan-se">
        </link>
        <updated>2017-09-22T08:03:07.000Z</updated>
        <content type="html"><![CDATA[<p>MacOS  NSButton 字体颜色
<strong>初始化NSbutton（这里就不做布局设置了）</strong></p>
<pre><code>NSButton *btn = [[NSButton alloc]init];
</code></pre>
<p><strong>设置button风格为Square</strong></p>
<pre><code>[btn setBezelStyle:NSBezelStyleRegularSquare];
</code></pre>
<p>**设置字体颜色 **</p>
<pre><code>[self setButtonColor: btn];
</code></pre>
<pre><code>- (void)setButtonColor:(NSButton*)btn{

NSMutableParagraphStyle*btnStyle = [[NSMutableParagraphStylealloc]init];

btnStyle.alignment=NSTextAlignmentCenter;

NSDictionary *dicAtt =@{NSForegroundColorAttributeName:[NSColor redColor],NSParagraphStyleAttributeName: btnStyle};

//给NSButton先赋值一个字符串，为的是后面替换，如果NSButton的title是空字符串的话，也会内存泄漏

btn.title=@&quot;清空全部&quot;;//这里的字符串长度要和后面的设置的长度一样 这里可以随便填

NSMutableAttributedString*attTitle = [[NSMutableAttributedString alloc]initWithAttributedString:btn.attributedTitle];

//替换文字

[attTitle replaceCharactersInRange:NSMakeRange(0,4)withString:@&quot;清空全部&quot;];

[attTitle addAttributes:dicAttrange:NSMakeRange(0,4)];

btn.attributedTitle= attTitle;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MacOS 文件拖入窗口]]></title>
        <id>https://gosling-dong.github.io/post/macos-wen-jian-tuo-ru-chuang-kou</id>
        <link href="https://gosling-dong.github.io/post/macos-wen-jian-tuo-ru-chuang-kou">
        </link>
        <updated>2017-09-21T08:33:28.000Z</updated>
        <content type="html"><![CDATA[<p>看到很多Mac上的工具类应用都可以直接拖入图片 或者 拖入文件直接使用，今天就来说一下文件拖入的使用方法</p>
<p>首先 新建一个文件继承NSView；
声明一个BOOL值</p>
<pre><code>@property(nonatomic,assign)BOOL isDragIn;
</code></pre>
<pre><code>- (void)drawRect:(NSRect)dirtyRect {

       [superdrawRect:dirtyRect];

       [self registerForDraggedTypes:[NSArray arrayWithObjects:NSFilenamesPboardType,nil]];

       if(_isDragIn) {

       NSLog(@&quot;拖拽了&quot;);

    }
}
</code></pre>
<pre><code>- (NSDragOperation)draggingEntered:(id)sender
{
_isDragIn=YES;

[self setNeedsDisplay:YES];

return NSDragOperationCopy;

}
</code></pre>
<pre><code>- (void)draggingExited:(id)sender{

_isDragIn=NO;

[self setNeedsDisplay:YES];

}
</code></pre>
<pre><code>- (BOOL)prepareForDragOperation:(id)sender{

_isDragIn=NO;

[self setNeedsDisplay:YES];

returnYES;

}
</code></pre>
<pre><code>- (BOOL)performDragOperation:(id)sender{

if([senderdraggingSource] !=self)

{

NSArray* filePaths = [[sender draggingPasteboard] propertyListForType:NSFilenamesPboardType];

NSLog(@&quot;文件地址%@&quot;,filePaths);

}

return YES;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MacOX  关于鼠标的停滞隐藏]]></title>
        <id>https://gosling-dong.github.io/post/macox-guan-yu-shu-biao-de-ting-zhi-yin-cang</id>
        <link href="https://gosling-dong.github.io/post/macox-guan-yu-shu-biao-de-ting-zhi-yin-cang">
        </link>
        <updated>2017-09-20T06:46:40.000Z</updated>
        <content type="html"><![CDATA[<p>MacOX  关于鼠标的停滞隐藏</p>
<p><strong>首先，mac上的鼠标事件和web一样，有悬停方法等。</strong></p>
<h1 id="开启鼠标悬停事件">开启鼠标悬停事件</h1>
<h3 id="先声明">先声明：</h3>
<pre><code>@property(nonatomic,strong) NSTrackingArea *trackingArea;
</code></pre>
<h2 id="在需要的时候调用这个方法">在需要的时候调用这个方法</h2>
<pre><code>-(void)openMouseOverflowEvent{

				NSTrackingAreaOptions  options = NSTrackingMouseEnteredAndExited | NSTrackingActiveAlways | NSTrackingMouseMoved;
				self.TrackingArea = [[NSTrackingArea alloc] initWithRect:self.view.bounds options:options owner:self.view userInfo:nil];
				[self.view addTrackingArea:self.trackingArea];
				NSLog(@&quot;开启鼠标悬停&quot;);
}
</code></pre>
<p>这样就开启了鼠标事件</p>
<p><strong>NSTrackingMouseEnteredAndExited  代表鼠标进入窗口和离开窗口</strong></p>
<p><strong>NSTrackingMouseMoved  代表鼠标在窗口上移动</strong></p>
<h2 id="鼠标进入窗口事件">鼠标进入窗口事件</h2>
<pre><code>- (void) mouseEntered:(NSEvent *) theEvent{

            if(self.trackingArea != nil) {
								NSLog(@&quot;鼠标进入控制器&quot;);
						}else{
							[self openMouseOverflowEvent];
           }
}
</code></pre>
<h2 id="鼠标离开窗口事件">鼠标离开窗口事件</h2>
<pre><code>-(void)mouseExited:(NSEvent*)theEvent{

      if(_trackingArea != nil) {
						 NSLog(@&quot;鼠标离开控制器&quot;);
     }else{
						[self closeMouseOverflowEvent];
}
</code></pre>
<h2 id="鼠标移动事件">鼠标移动事件</h2>
<pre><code>- (void)mouseMoved:(NSEvent*)event{
     NSLog(@&quot;鼠标移动&quot;);
}
</code></pre>
<h2 id="关闭鼠标悬停事件">关闭鼠标悬停事件</h2>
<pre><code>- (void)closeMouseOverflowEvent{
				[self.view removeTrackingArea:_trackingArea];
				_trackingArea=nil;
				NSLog(@&quot;关闭鼠标悬停&quot;);
}
</code></pre>
<p><em><strong>接下来说一说 鼠标隐藏方法</strong></em></p>
<h2 id="鼠标隐藏">鼠标隐藏</h2>
<pre><code>//隐藏鼠标
[NSCursor setHiddenUntilMouseMoves:YES];
</code></pre>
<h3 id="使用">使用</h3>
<pre><code>dispatch_queue_t  queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_after(dispatch_time(DISPATCH_TIME_NOW,  (int64_t)(2.5*NSEC_PER_SEC)),  queue, ^{
[NSCursor setHiddenUntilMouseMoves:YES];
});
</code></pre>
]]></content>
    </entry>
</feed>